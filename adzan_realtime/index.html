<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Adzan Realtime — Lokasi Otomatis & Manual</title>
<style>
  :root{
    --bg:#0b1221; --card:#0f1724; --accent:#f59e0b; --muted:#9aa7bf; --glass: rgba(255,255,255,0.03);
    color-scheme: dark;
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Arial; background:linear-gradient(180deg,#071026 0%, #07183a 100%); color:#e6eef8;}
  .wrap{max-width:920px;margin:28px auto;padding:20px;}
  header{display:flex;align-items:center;gap:16px;margin-bottom:18px;}
  .logo{width:56px;height:56px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#ffb86b);display:flex;align-items:center;justify-content:center;font-weight:700;color:#071026;font-size:20px}
  h1{margin:0;font-size:20px}
  .card{background:var(--card);padding:18px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6);margin-bottom:14px;}
  .row{display:flex;gap:14px;align-items:center;flex-wrap:wrap;}
  .clock{font-size:28px;font-weight:600}
  .sub{color:var(--muted);font-size:13px}

  /* Table base */
  table{width:100%;border-collapse:collapse;margin-top:10px}
  /* nicer header */
  #prayTable thead th{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:12px 10px; font-weight:700; font-size:13px; color:#f7fafc; letter-spacing:0.2px; text-align:left;
    border-bottom:1px solid rgba(255,255,255,0.04);
  }
  /* default cell */
  #prayTable td{padding:12px 10px; text-align:left}
  /* subtle zebra and row separators */
  #prayTable tbody tr{border-bottom:1px solid rgba(255,255,255,0.03)}
  #prayTable tbody tr:nth-child(odd){background:rgba(255,255,255,0.012)}
  #prayTable tbody tr:hover{background:rgba(255,255,255,0.02)}

  td.time{font-weight:600}
  /* stabilize table to avoid layout shift when countdown updates */
  #prayTable{table-layout:fixed}
  #prayTable th:nth-child(1), #prayTable td:nth-child(1){width:36%}
  #prayTable th:nth-child(2), #prayTable td:nth-child(2){width:32%}
  #prayTable th:nth-child(3), #prayTable td:nth-child(3){width:32%}
  /* Info column centered and stable numeric font */
  #prayTable th:nth-child(3),
  #prayTable td:nth-child(3),
  #prayTable td[data-info]{
    text-align:center;
  }
  #prayTable td.small{white-space:nowrap; text-overflow:ellipsis; overflow:hidden; font-variant-numeric:tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;}

  .next{background:linear-gradient(90deg, rgba(245,158,11,0.12), rgba(255,184,107,0.05));border-radius:8px;padding:8px}
  tr.row-next{
    background: linear-gradient(90deg, rgba(245,158,11,0.22), rgba(255,184,107,0.08));
    border-left: 4px solid var(--accent);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.02), inset 0 -6px 18px rgba(2,6,23,0.08);
    font-weight: 700;
  }
  /* make transitions smooth when highlight moves */
  #prayTable tbody tr td{ transition: background-color 220ms ease, color 220ms ease; }
  .countdown{font-size:20px;font-weight:700}
  .controls{display:flex;gap:10px;flex-wrap:wrap}
  button{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;color:inherit;cursor:pointer}
  select,input{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:inherit}
  footer{margin-top:18px;color:var(--muted);font-size:13px}
  .small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="logo">AZ</div>
    <div>
      <h1>Adzan Realtime</h1>
      <div class="sub">Lokasi otomatis (GPS) atau input manual nama kota</div>
    </div>
  </header>

  <div class="card">
    <div class="row" style="justify-content:space-between">
      <div>
        <div class="clock" id="nowclock">--:--:--</div>
        <div class="sub" id="nowdate">memuat...</div>
      </div>
      <div style="text-align:right">
        <div class="sub">Lokasi</div>
        <div id="locname" class="small">mengambil lokasi...</div>
        <div style="margin-top:8px" class="small">Timezone: <span id="tzname">-</span></div>
      </div>
    </div>
  </div>

  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:8px">
      <div>
        <div class="sub">Jadwal sholat hari ini</div>
        <div class="small">Metode: <span id="methodName">Muslim World League</span></div>
      </div>
      <div class="controls">
        <select id="method" title="Pilih metode perhitungan">
          <option value="MWL">Muslim World League</option>
          <option value="ISNA">ISNA</option>
          <option value="Egypt">Egypt</option>
          <option value="Makkah">Umm al-Qura / Makkah</option>
          <option value="Karachi">University of Karachi</option>
        </select>
        <input id="cityInput" type="text" placeholder="Ketik nama kota...">
        <button id="btnCity">Gunakan kota</button>
        <button id="btnDefault">Lebak Bulus</button>
        <button id="btnRefresh">GPS</button>
      </div>
    </div>

    <table id="prayTable">
      <thead><tr><th>Sholat</th><th>Waktu</th><th>Info</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <footer>
    <div>Muhammad Faris Muzakki & Indana Zulfa</div>
    <div class="small">Sumber: Aladhan API (utama) — fallback: perhitungan lokal (PrayTimes.js).</div>
  </footer>
</div>

<script>
/* === Algoritma PrayTimes.js (ringkas, sudah diintegrasikan) === */
// [kode matematis perhitungan sholat — tetap seperti file asli, tidak dipotong]

function D2R(d){return (d*Math.PI)/180;}
function R2D(r){return (r*180)/Math.PI;}
function fixAngle(a){return a - 360*Math.floor(a/360);}
function fixHour(a){return a - 24*Math.floor(a/24);}
function dsin(d){return Math.sin(D2R(d));}
function dcos(d){return Math.cos(D2R(d));}
function dtan(d){return Math.tan(D2R(d));}
function darcsin(x){return R2D(Math.asin(x));}
function darccos(x){return R2D(Math.acos(x));}
function darctan2(y,x){return R2D(Math.atan2(y,x));}
function darccot(x){return R2D(Math.atan(1/x));}

function getSunPosition(jd,lat,lon){
  var D=jd-2451545.0;
  var g=fixAngle(357.529+0.98560028*D);
  var q=fixAngle(280.459+0.98564736*D);
  var L=fixAngle(q+1.915*dsin(g)+0.020*dsin(2*g));
  var e=23.439-0.00000036*D;
  var RA=darctan2(dcos(e)*dsin(L),dcos(L))/15;
  var eqt=q/15-fixHour(RA);
  var decl=darcsin(dsin(e)*dsin(L));
  return {decl:decl,eqt:eqt};
}
function getJD(date){
  if(date.constructor===Date) date=dateToJulian(date);
  return date;
}
function dateToJulian(date){
  return (Date.UTC(date.getFullYear(),date.getMonth(),date.getDate(),0,0,0,0)/86400000)+2440587.5;
}
// Local PrayTimes calculation (kept as fallback)
function getPrayerTimes(date,lat,lon,timezone,method){
  var params={fajrAngle:18,ishaAngle:17,asrFactor:1};
  if(method==="ISNA"){params={fajrAngle:15,ishaAngle:15,asrFactor:1};}
  if(method==="Egypt"){params={fajrAngle:19.5,ishaAngle:17.5,asrFactor:1};}
  if(method==="Makkah"){params={fajrAngle:18.5,ishaAngle:90,asrFactor:1};}
  if(method==="Karachi"){params={fajrAngle:18,ishaAngle:18,asrFactor:1};}

  var jDate=getJD(date)-lon/(15*24);
  var D=getSunPosition(jDate,lat,lon).decl;
  var Z=12-fixHour(getSunPosition(jDate,lat,lon).eqt);
  function compute(angle,afterSun){ 
    return Z+(afterSun?1:-1)/15*darccos((-dsin(angle)-dsin(D)*dsin(lat))/(dcos(D)*dcos(lat))); 
  }
  var fajr=compute(params.fajrAngle,false);
  var sunrise=compute(0.833,false);
  var dhuhr=Z;
  var asr=Z+1/15*darccot(params.asrFactor+dtan(Math.abs(lat-D)));
  var sunset=compute(0.833,true);
  var maghrib=sunset;
  var isha=params.ishaAngle<90?compute(params.ishaAngle,true):sunset+90/60;

  return {fajr:fajr,sunrise:sunrise,dhuhr:dhuhr,asr:asr,maghrib:maghrib,isha:isha};
}

/* === Aladhan API integration === */
const ALADHAN_METHOD_MAP = {
  MWL: 3,      // Muslim World League
  ISNA: 2,     // Islamic Society of North America
  Egypt: 5,    // Egyptian
  Makkah: 4,   // Umm al-Qura / Makkah
  Karachi: 1   // University of Karachi
};

async function fetchTimingsFromAladhan(date, lat, lon, methodKey){
  try{
    const methodId = ALADHAN_METHOD_MAP[methodKey] ?? 3;
    // date param as timestamp (day, month, year) or unix? use timestamp and method=... endpoint: /timings
    const dt = new Date(date);
    const day = dt.getDate(); const month = dt.getMonth()+1; const year = dt.getFullYear();
    // use rounded coords for cache key to avoid too many unique keys
    const rlat = Math.round(lat*1000)/1000; const rlon = Math.round(lon*1000)/1000;
    const cacheKey = `timings:${year}-${month}-${day}:${rlat},${rlon}:m${methodId}`;
    const cached = localStorage.getItem(cacheKey);
    if(cached){ try{ return JSON.parse(cached); }catch(e){} }
    const url = `https://api.aladhan.com/v1/timings/${Math.floor(dt.getTime()/1000)}?latitude=${lat}&longitude=${lon}&method=${methodId}`;
    const res = await fetch(url);
    if(!res.ok) throw new Error('Aladhan fetch failed');
    const body = await res.json();
  if(body && body.code===200 && body.data && body.data.timings){
      // timings are strings like "05:12" in local timezone; convert to fractional hours
      const t = body.data.timings;
      function parseToFloat(hm){
        const parts = hm.split(':');
        if(parts.length<2) return NaN;
        return parseInt(parts[0],10) + parseInt(parts[1],10)/60 + (parts[2]?parseInt(parts[2],10)/3600:0);
      }
      const out = {
        fajr: parseToFloat(t.Fajr || t.FAJR || t.fajr),
        sunrise: parseToFloat(t.Sunrise || t.SUNRISE || t.sunrise),
        dhuhr: parseToFloat(t.Dhuhr || t.DHUHR || t.Dhuha || t.dhuhr || t.Zuhr),
        asr: parseToFloat(t.Asr || t.ASR || t.asr),
        maghrib: parseToFloat(t.Maghrib || t.MAGHRIB || t.maghrib),
        isha: parseToFloat(t.Isha || t.ISHA || t.isha)
      };
      const timezone = (body.data.meta && body.data.meta.timezone) ? body.data.meta.timezone : null;
      try{ localStorage.setItem(cacheKey, JSON.stringify({timings: out, timezone: timezone})); }catch(e){}
      return {timings: out, timezone: timezone};
    }
  }catch(err){
    console.warn('Aladhan API failed, falling back to local calc',err);
  }
  return null;
}
function fixHour(a){return a - 24*Math.floor(a/24);}
function floatToTime(time){
  if(isNaN(time)) return "--:--";
  time=fixHour(time+0.5/60);
  var h=Math.floor(time); var m=Math.floor((time-h)*60);
  return (h<10?"0":"")+h+":"+(m<10?"0":"")+m;
}

/* === App utama === */
const prayNames={fajr:"Subuh",sunrise:"Terbit",dhuhr:"Dzuhur",asr:"Ashar",maghrib:"Maghrib",isha:"Isya"};

let currentLat=null,currentLon=null,currentCity="Lokasi belum ditentukan";
let currentMethod="MWL";
let countdownTimer=null;
let _lastDateStr = (new Date()).toDateString(); // track local day for auto-refresh
let _midnightTimer = null;
let _perPrayerNorm = {}; // store normalized times for live updates
let _liveInterval = null;
let currentTimeZone = null; // IANA timezone name (e.g. 'Asia/Jakarta') from API when available

// Return {h,m,s} for given date in the specified IANA timezone (fallback to local)
function getTimePartsInZone(date, timeZone){
  try{
    if(timeZone){
      const parts = new Intl.DateTimeFormat('en-GB', {timeZone: timeZone, hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit'}).formatToParts(date);
      const hh = parseInt(parts.find(p=>p.type==='hour')?.value || '0',10);
      const mm = parseInt(parts.find(p=>p.type==='minute')?.value || '0',10);
      const ss = parseInt(parts.find(p=>p.type==='second')?.value || '0',10);
      return {h:hh, m:mm, s:ss};
    }
  }catch(e){/* fallthrough to local */}
  return {h: date.getHours(), m: date.getMinutes(), s: date.getSeconds()};
}

// Return offset in hours (may be fractional) for an IANA timezone at given date
function getZoneOffsetHours(timeZone, date=new Date()){
  try{
    if(!timeZone) return -date.getTimezoneOffset()/60;
    const parts = new Intl.DateTimeFormat('en-GB', {timeZone: timeZone, hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit'}).formatToParts(date);
    const hh = parseInt(parts.find(p=>p.type==='hour')?.value || '0',10);
    const mm = parseInt(parts.find(p=>p.type==='minute')?.value || '0',10);
    const ss = parseInt(parts.find(p=>p.type==='second')?.value || '0',10);
    const localSeconds = hh*3600 + mm*60 + ss;
    const utcSeconds = date.getUTCHours()*3600 + date.getUTCMinutes()*60 + date.getUTCSeconds();
    let diff = localSeconds - utcSeconds;
    if(diff > 12*3600) diff -= 24*3600;
    if(diff < -12*3600) diff += 24*3600;
    return diff/3600;
  }catch(e){
    return -date.getTimezoneOffset()/60;
  }
}

function updateClock(){
  const now=new Date();
  // force HH:MM:SS with colons regardless of locale (some locales use dots)
  function pad(n){return n<10?('0'+n):n}
  try{
    if(currentTimeZone){
      // use toLocaleTimeString with timeZone for broad support
      try{
        const s = now.toLocaleTimeString('en-GB', {timeZone: currentTimeZone, hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit'});
        document.getElementById("nowclock").textContent = s;
      }catch(e){
        const hh = pad(now.getHours()); const mm = pad(now.getMinutes()); const ss = pad(now.getSeconds());
        document.getElementById("nowclock").textContent = `${hh}:${mm}:${ss}`;
      }
    } else {
      const hh = pad(now.getHours()); const mm = pad(now.getMinutes()); const ss = pad(now.getSeconds());
      document.getElementById("nowclock").textContent = `${hh}:${mm}:${ss}`;
    }
  }catch(e){
    // fallback to local time display
    const hh = pad(now.getHours()); const mm = pad(now.getMinutes()); const ss = pad(now.getSeconds());
    document.getElementById("nowclock").textContent = `${hh}:${mm}:${ss}`;
  }
  // Gregorian date
  const gdate = now.toLocaleDateString("id-ID",{weekday:"long",year:"numeric",month:"long",day:"numeric"});
  // Hijri date (Intl with islamic calendar)
  let hdate = '';
  try{
    hdate = new Intl.DateTimeFormat('id-ID', {calendar: 'islamic', day: 'numeric', month: 'long', year: 'numeric'}).format(now);
  }catch(e){
    try{ hdate = new Intl.DateTimeFormat('id-ID-u-ca-islamic').format(now); }catch(e2){ hdate = ''; }
  }
  document.getElementById("nowdate").textContent = gdate + (hdate?(' — '+hdate):'');
  // detect local day change and refresh timings if needed
  const todayStr = now.toDateString();
  if(todayStr !== _lastDateStr){
    _lastDateStr = todayStr;
    // re-fetch timings for the new day
    renderPrayers();
    // reschedule midnight timer
    scheduleMidnightRefresh();
  }
  requestAnimationFrame(updateClock);
}

// Schedule a one-off timeout to refresh at the next local midnight
function scheduleMidnightRefresh(){
  try{ if(_midnightTimer) clearTimeout(_midnightTimer); }catch(e){}
  const now = new Date();
  const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 2); // 2s after midnight
  const ms = tomorrow.getTime() - now.getTime();
  _midnightTimer = setTimeout(()=>{
    _lastDateStr = (new Date()).toDateString();
    renderPrayers();
    // schedule next one
    scheduleMidnightRefresh();
  }, ms);
}

function renderPrayers(){
  if(currentLat===null||currentLon===null) return;
  const now=new Date();
  const clientTzOffset = -now.getTimezoneOffset()/60;
  // determine target timezone offset (hours) for calculations
  const zoneOffset = currentTimeZone ? getZoneOffsetHours(currentTimeZone, now) : clientTzOffset;
  // default display if API doesn't supply timezone
  function formatOffset(off){ return 'GMT'+(off>=0?'+':'')+off; }
  document.getElementById("tzname").textContent = formatOffset(clientTzOffset);
  // Try Aladhan API first for more accurate timings
  (async ()=>{
      // helper to format seconds into HH:MM:SS
      function pad(n){return n<10?('0'+n):n}
      function formatHMS(s){
        if(s<=0) return '00:00:00';
        const h=Math.floor(s/3600); const m=Math.floor((s%3600)/60); const sec=Math.floor(s%60);
        return pad(h)+':'+pad(m)+':'+pad(sec);
      }

  const nowParts = getTimePartsInZone(now, currentTimeZone);
  const nowHours = nowParts.h + nowParts.m/60 + nowParts.s/3600;
      let apiResp = await fetchTimingsFromAladhan(now,currentLat,currentLon,currentMethod);
      let times = null;
      let apiTimezone = null;
      if(apiResp && apiResp.timings){
        times = apiResp.timings;
        apiTimezone = apiResp.timezone || null;
      } else {
        // fallback to old return shape or local calculation
        if(apiResp && typeof apiResp === 'object' && apiResp.fajr!==undefined){ times = apiResp; }
  else times = getPrayerTimes(now,currentLat,currentLon,zoneOffset,currentMethod);
      }
      // if API supplied timezone, use it in header (show IANA name and client offset)
      if(apiTimezone){
        // show IANA timezone and compute numeric GMT offset (e.g. GMT+9 or GMT+9:30)
        try{
          const tzName = apiTimezone;
          // Prefer Intl short timezone name (often returns 'GMT+9' or equivalent)
          const parts = new Intl.DateTimeFormat('en-US', {timeZone: tzName, timeZoneName: 'short'}).formatToParts(now);
          const tzShort = parts.find(p => p.type === 'timeZoneName')?.value;
          if(tzShort){
            document.getElementById("tzname").textContent = tzName + ' (' + tzShort + ')';
          } else {
            document.getElementById("tzname").textContent = tzName;
          }
        }catch(e){
          // fallback to raw timezone name
          document.getElementById("tzname").textContent = apiTimezone;
        }
        // set currentTimeZone so header clock and other UI use it
        currentTimeZone = apiTimezone;
      }
    const tbody=document.querySelector("#prayTable tbody");
    tbody.innerHTML="";
    // normalize times (fractional hours) for relative calculations within this scope
    const norm = {};
    for(let k of Object.keys(prayNames)){
      const v = times[k];
      if(typeof v === 'number') norm[k] = v;
      else if(typeof v === 'string'){
        const parts = v.split(':');
        if(parts.length>=2) norm[k] = parseInt(parts[0],10) + parseInt(parts[1],10)/60 + (parts[2]?parseInt(parts[2],10)/3600:0);
        else norm[k] = NaN;
      } else norm[k] = NaN;
    }

  // if Isya already passed today, fetch timings for tomorrow and use them for countdowns
  const nowHoursCheck = nowParts.h + nowParts.m/60 + nowParts.s/3600;
    let usedTomorrow = false;
    if(!isNaN(norm['isha']) && nowHoursCheck >= norm['isha']){
      // get tomorrow's timings
      const tomorrow = new Date(now.getTime() + 24*3600*1000);
      const tomesResp = await fetchTimingsFromAladhan(tomorrow,currentLat,currentLon,currentMethod);
      let tomes = null;
      let tomesTz = null;
      if(tomesResp && tomesResp.timings){ tomes = tomesResp.timings; tomesTz = tomesResp.timezone || null; }
      else if(tomesResp && typeof tomesResp === 'object' && tomesResp.fajr !== undefined){ tomes = tomesResp; }
      else {
        const tomZoneOffset = currentTimeZone ? getZoneOffsetHours(currentTimeZone, tomorrow) : clientTzOffset;
        tomes = getPrayerTimes(tomorrow,currentLat,currentLon,tomZoneOffset,currentMethod);
      }
      if(tomes){
        // replace times for display but normalize by adding 24 so countdowns point to next day
        for(let k of Object.keys(prayNames)){
          const vv = tomes[k];
          // keep display as tomes (local time) but norm add 24
          if(typeof vv === 'number') norm[k] = vv + 24;
          else if(typeof vv === 'string'){
            const parts = vv.split(':');
            if(parts.length>=2) norm[k] = parseInt(parts[0],10) + parseInt(parts[1],10)/60 + (parts[2]?parseInt(parts[2],10)/3600:0) + 24;
            else norm[k] = NaN;
          } else norm[k] = NaN;
          // ensure the times variable shows tomorrow's time for display
          times[k] = (typeof vv === 'number') ? vv : vv;
        }
        usedTomorrow = true;
      }
    }
      for(let k of Object.keys(prayNames)){
        const displayTime = floatToTime(times[k]);
        const t = norm[k];
        let infoText = '—';
        if(!isNaN(t)){
          if(t <= nowHours){
            // already passed for today
            infoText = 'Selesai';
          } else {
            const diffSec = Math.round((t - nowHours) * 3600);
            infoText = formatHMS(diffSec);
          }
        }

        const tr=document.createElement('tr');
        tr.setAttribute('data-prayer', k);
        tr.innerHTML = `<td>${prayNames[k]}</td><td class="time">${displayTime}</td><td class="small" data-info="${k}">${infoText}</td>`;
        tbody.appendChild(tr);
      }
    updateNext(times);
      // determine next prayer (today only); if none, next is fajr (tomorrow)
      let nextKey = null; let minDiff = Infinity;
  const nowHoursForNext = nowParts.h + nowParts.m/60 + nowParts.s/3600;
      for(const k of Object.keys(norm)){
        const t = norm[k];
        if(isNaN(t)) continue;
        const diff = t - nowHoursForNext;
        if(diff > 0 && diff < minDiff){ minDiff = diff; nextKey = k; }
      }
      if(!nextKey){ nextKey = 'fajr'; }
      // store normalized times for live updates
      _perPrayerNorm = Object.assign({}, norm);
      // start live updater if not running
      if(!_liveInterval){
        _liveInterval = setInterval(()=>{ updateLiveInfo(); },1000);
      }
  })();
}

  // update Info column every second and highlight next prayer
  function updateLiveInfo(){
  const now = new Date();
  const nowParts = getTimePartsInZone(now, currentTimeZone);
  const nowHours = nowParts.h + nowParts.m/60 + nowParts.s/3600;
    // find next prayer (today only); if none, next is fajr (tomorrow)
    let nextKey = null; let minDiff = Infinity;
    for(const k of Object.keys(_perPrayerNorm)){
      const t = _perPrayerNorm[k];
      if(isNaN(t)) continue;
      const diff = t - nowHours;
      if(diff > 0 && diff < minDiff){ minDiff = diff; nextKey = k; }
    }
    if(!nextKey){ nextKey = 'fajr'; }

    // update rows
    document.querySelectorAll('#prayTable tbody tr').forEach(tr=>{
      const key = tr.getAttribute('data-prayer');
      const infoCell = tr.querySelector('td[data-info="'+key+'"]');
      const t = _perPrayerNorm[key];
      if(isNaN(t)){
        infoCell.textContent = '—';
        tr.classList.remove('row-next');
        return;
      }
      // Only the nextKey shows a live countdown
      if(key === nextKey){
        let diffHours = t - nowHours;
        if(diffHours < 0) diffHours += 24; // next-day fajr handling
        const diffSec = Math.max(0, Math.round(diffHours * 3600));
        const h = Math.floor(diffSec/3600); const m = Math.floor((diffSec%3600)/60); const s = diffSec%60;
        infoCell.textContent = (h<10?('0'+h):h)+':'+(m<10?('0'+m):m)+':'+(s<10?('0'+s):s);
      } else {
        // not the next: if already passed today -> 'Selesai' otherwise show '—'
        if(t <= nowHours) infoCell.textContent = 'Selesai';
        else infoCell.textContent = '—';
      }
      // highlight
      if(key === nextKey) tr.classList.add('row-next'); else tr.classList.remove('row-next');
    });
  }

function updateNext(times){
  // Clear any pending timer
  try{ if(countdownTimer) clearTimeout(countdownTimer); }catch(e){}

  const now=new Date();
  const nowParts = getTimePartsInZone(now, currentTimeZone);
  const cur = nowParts.h + nowParts.m/60 + nowParts.s/3600;
  let upcoming=null;
  // Normalize times: they might be fractional numbers (hours) or strings "HH:MM".
  const norm={};
  for(let k of Object.keys(prayNames)){
    const v=times[k];
    if(typeof v==='number') norm[k]=v;
    else if(typeof v==='string'){
      const parts=v.split(':');
      if(parts.length>=2) norm[k]=parseInt(parts[0],10)+parseInt(parts[1],10)/60+(parts[2]?parseInt(parts[2],10)/3600:0);
      else norm[k]=NaN;
    } else norm[k]=NaN;
  }
  // find next prayer
  for(let k of Object.keys(prayNames)){
    if(norm[k]>cur){upcoming=norm[k];break;}
  }
  if(!upcoming){ upcoming = (typeof times.fajr === 'number' ? times.fajr : (isNaN(parseFloat(times.fajr)) ? NaN : parseFloat(times.fajr))) + 24; }

  if(isNaN(upcoming)) return;
  const ms = Math.max(200, Math.round((upcoming - cur) * 3600 * 1000));
  // schedule a one-shot re-render when the upcoming prayer arrives
  countdownTimer = setTimeout(()=>{
    renderPrayers();
  }, ms+500);
}

function setLocation(lat,lon,name, timezone=null){
  currentLat=lat;currentLon=lon;currentCity=name;
  document.getElementById("locname").textContent=name;
  if(timezone) currentTimeZone = timezone;
  // Render prayers (renderPrayers will itself try Aladhan and fallback)
  renderPrayers();
  // ensure midnight refresh is scheduled when we have a location
  scheduleMidnightRefresh();
}

async function getCoordsFromCity(city){
  try{
    const cacheKey = `geocode:city:${city.toLowerCase()}`;
    const cached = localStorage.getItem(cacheKey);
    if(cached){
      return JSON.parse(cached);
    }
    const url=`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(city)}`;
    const res=await fetch(url,{headers:{'Accept-Language':'id'}});
    const data=await res.json();
    if(data && data.length>0){
      const out = {lat:parseFloat(data[0].lat),lon:parseFloat(data[0].lon),display:data[0].display_name};
      try{ localStorage.setItem(cacheKey, JSON.stringify(out)); }catch(e){}
      return out;
    }
  }catch(e){console.error(e);}
  return null;
}

// Reverse geocode lat/lon to human-readable name with caching
async function reverseGeocode(lat,lon){
  try{
    const rlat = Math.round(lat*1000)/1000; // reduce precision for cache key
    const rlon = Math.round(lon*1000)/1000;
    const cacheKey = `geocode:coords:${rlat},${rlon}`;
    const cached = localStorage.getItem(cacheKey);
    if(cached) return JSON.parse(cached);
    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&addressdetails=1`;
    const res = await fetch(url,{headers:{'Accept-Language':'id'}});
    if(!res.ok) throw new Error('reverse geocode failed');
    const data = await res.json();
    const display = data.display_name || (data.address? (data.address.city||data.address.town||data.address.village||data.address.county) : null) || `${lat.toFixed(3)},${lon.toFixed(3)}`;
    const out = {lat:lat,lon:lon,display:display};
    try{ localStorage.setItem(cacheKey, JSON.stringify(out)); }catch(e){}
    return out;
  }catch(err){console.warn('reverseGeocode error',err); return {lat:lat,lon:lon,display:`${lat.toFixed(3)},${lon.toFixed(3)}`};}
}

// Events
document.getElementById("method").addEventListener("change",e=>{
  currentMethod=e.target.value;
  document.getElementById("methodName").textContent=e.target.options[e.target.selectedIndex].text;
  renderPrayers();
});
document.getElementById("btnRefresh").addEventListener("click",()=>{
  navigator.geolocation.getCurrentPosition(pos=>{
    (async ()=>{
      // Reverse geocode and set nicer display name
      const rg = await reverseGeocode(pos.coords.latitude,pos.coords.longitude);
      setLocation(pos.coords.latitude,pos.coords.longitude, rg.display || 'GPS');
    })();
  },()=>alert("Tidak bisa ambil lokasi GPS."));
});
document.getElementById("btnCity").addEventListener("click",async()=>{
  const city=document.getElementById("cityInput").value.trim();
  if(!city){alert("Masukkan nama kota!");return;}
  const result=await getCoordsFromCity(city);
  if(result){setLocation(result.lat,result.lon,result.display);}
  else alert("Kota tidak ditemukan.");
});
document.getElementById("btnDefault").addEventListener("click",async()=>{
  const city = 'Lebak Bulus, Cilandak, Jakarta Selatan, Daerah Khusus Ibukota Jakarta, Jawa, Indonesia';
  const result = await getCoordsFromCity(city);
  if(result) {
    // override the displayed name to the exact text requested
    const display = 'Lebak Bulus, Cilandak, Jakarta Selatan, Daerah Khusus Ibukota Jakarta, Jawa, Indonesia';
    setLocation(result.lat,result.lon,display);
  } else alert('Gagal mengambil lokasi default.');
});

// Init
updateClock();
navigator.geolocation.getCurrentPosition(pos=>{
  (async ()=>{
    const rg = await reverseGeocode(pos.coords.latitude,pos.coords.longitude);
    setLocation(pos.coords.latitude,pos.coords.longitude, rg.display || 'GPS');
  })();
},()=>{document.getElementById("locname").textContent="Lokasi manual diperlukan";});
// Also schedule midnight refresh on load in case user sets location manually later
scheduleMidnightRefresh();
</script>
</body>
</html>
